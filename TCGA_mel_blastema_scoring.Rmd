---
title: "TCGA_mel_blastema_scoring"
author: "Maya Emmons-Bell"
date: '2022-06-08'
output: html_document
---

Using data from the TCGA SKCM project (human melanoma transcriptomics data from more than 400 patients), explore correlations between blastema-like gene expression and 
tumor type (primary, metastatic), days to death, etc. 


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

load libraries 
```{r}
library(clusterProfiler)
library(org.Hs.eg.db)
library(biomaRt)
library(EnsDb.Hsapiens.v86)
library(dplyr)
library(tidyverse)
```

Pre-process transcriptome data from the TCGA-SKCM project. 
Data was downloaded from TCGA using a custom R script (found in same GitHub repo).
```{r}
#get ensembl IDs to translate (remove first entry, which is the "barcode" col name)
#could also remove the ".X" version number so IDs match reference (with #%>% gsub("\\..*", "",.) ); if you do this you need to alter the downstream
#biomaRt code.
ensids_to_translate <- colnames(rpkm) %>% .[-1] %>% as.data.frame() 
colnames(ensids_to_translate) <- c("ENSEMBL")
    
#use biomaRt to translate ensemblIDs to gene symbols, mark un-translated IDs with "NA", drop those columns 
listEnsembl()
ensembl <- useEnsembl(biomart = "genes")
datasets <- listDatasets(ensembl)

ensembl.con <- useMart("ensembl", dataset = "hsapiens_gene_ensembl")

attr <- listAttributes(ensembl.con)
filt <- listFilters(ensembl.con)

translated <- getBM(attributes = c("ensembl_gene_id_version", "external_gene_name"), 
      filters = "ensembl_gene_id_version", 
      values = ensids_to_translate, 
      mart = ensembl.con)

ensids_to_translate <- as.data.frame(ensids_to_translate)
colnames(ensids_to_translate) <- c("ensembl_gene_id_version")

merged <- merge(translated, ensids_to_translate, by = "ensembl_gene_id_version", all.y=TRUE)
new_names <- merged$external_gene_name
new_names <- append("sample", new_names)
head(new_names)

colnames(rpkm) <- new_names

#drop un-translated genes
rpkm_filtered <- rpkm[!is.na(names(rpkm))]
```

We now have a nice expression matrix (samples X genes)
Since this TCGA project is level 2, the data has already been normalized 
Calculate total module expression per sample 
```{r}
blastema_genes <- c("sample", "HMGB2", "KRT18", "HMGN2", "F3", "KRT4", "PDGFRA", "COL1A1", "SERPINE1", "TNFAIP6", "CFL1", 
              "NPM1", "VMP1", "PCP4",  "ECRG4", "POSTN", "SPARC", "LEP", "OGN", "C1QTNF5", "HMGA1", "H3-3A", "STMN1", "RPA2", "PCNA", "CCN1", 
              "BHMT", "HGD", "PTGDS")
#this threw an error, because `MDK`, `DKK3`, `COL1A2`, `CALM2`, and `RBP4` don't exist in the TCGA data - removing them from blastema gene set 

#select only blastema gene expression 
rpkm_filtered_blastema_gene_subset <- rpkm_filtered %>% dplyr::select(blastema_genes)

#sum total expression of blastema genes 
rpkm_filtered_blastema_gene_subset$total_blastema_expn <- rowSums(rpkm_filtered_blastema_gene_subset[,2:29])
#calculate percentage of all reads that are blastema genes
rpkm_filtered_blastema_gene_subset$total_expn <- rowSums(rpkm_filtered[,2:54811])
rpkm_filtered_blastema_gene_subset$ratio_blastema <- ((rpkm_filtered_blastema_gene_subset$total_blastema_expn) / (rpkm_filtered_blastema_gene_subset$total_expn ))*100

```

Visualize distribution of blastema gene scores 
```{r}
#plot distribution of total blastema gene expression scores
p1 <-rpkm_filtered_blastema_gene_subset %>%
  ggplot(aes(x=total_blastema_expn)) +
  geom_density(fill="yellow")
#there's definitely a population of samples that have higher total blastema gene expn
#worth exploring if those samples have different outcomes
```

Add metadata to blastema score info
```{r}
#get metadata info
unique(colnames(metadata_filtered))

#select metadata of interest
metadata_filtered <- metadata %>% dplyr::select(c("barcode", "definition", "tumor_descriptor", "sample_type", "ajcc_pathologic_stage", "primary_diagnosis", "race", "gender", "vital_status", "days_to_death", "tumor_grade", "paper_MethTypes.201408", "paper_RNASEQ.CLUSTER_CONSENHIER" ))

metadata_filtered$blastema_score <- rpkm_filtered_blastema_gene_subset$total_blastema_expn
metadata_filtered <- metadata_filtered %>% dplyr::rename(sample = barcode)

pca_matrix <- rpkm_filtered_blastema_gene_subset[,1:29]
pca_matrix <- column_to_rownames(pca_matrix, var = "sample")
sample_pca <- prcomp(pca_matrix)

pc_scores <- sample_pca$x
pc_scores <- pc_scores %>% 
  # convert to a tibble retaining the sample names as a new column
  as_tibble(rownames = "sample")

pc_scores <- merge(pc_scores,metadata_filtered, by = "sample" )
pc_scores$is_blastema <- rpkm_filtered$is_blastema

pc_scores %>% 
  # create the plot
  ggplot(aes(x = PC1, y = PC2)) +
  geom_point(aes(colour = factor(is_blastema))) +
  

```

Calculate blastema reads / total reads, plot 
```{r}
#add metadata to 

rpkm_filtered_blastema_gene_subset_meta <- merge(rpkm_filtered_blastema_gene_subset, metadata_filtered, by = "sample")

p3 <- rpkm_filtered_blastema_gene_subset_meta %>%
  ggplot(aes(x=total_blastema_expn, y = total_expn)) +
  geom_point(aes(colour = factor(sample_type))) +
  theme_classic()

p4 <- rpkm_filtered_blastema_gene_subset_meta %>% ggplot(aes(x = factor(sample_type),
           y = ratio_blastema,
           fill = sample_type)) +
  geom_bar(stat = "identity",
           position = "dodge") +
  geom_jitter() +
  theme_bw()


data_for_t_test <-subset(rpkm_filtered_blastema_gene_subset_meta, sample_type !="Solid Tissue Normal" & sample_type !="Additional Metastatic")

#t = 3.3344, df = 452.98, p-value = 0.0009249
t_test <- t.test(ratio_blastema ~ sample_type, data_for_t_test)

wilcox_test <- wilcox.test(ratio_blastema ~ sample_type, data_for_t_test)

#apparently i'm supposed to use t.test (welch), but why are the p values for the two tests different..... 



```

Run PCA on whole dataset
```{r}
#add 
rpkm_filtered$ratio_blastema <- rpkm_filtered_blastema_gene_subset$ratio_blastema

#add is_blastema column that marks cells with greater than 0.5% reads == blastema
blastema_cutoff <- 0.5
rpkm_filtered$is_blastema <- NULL
for(i in 1:length(rpkm_filtered$ratio_blastema)){
  if(rpkm_filtered$ratio_blastema[i] > blastema_cutoff) {
    rpkm_filtered$is_blastema[i] <- TRUE
  } else {
    rpkm_filtered$is_blastema[i] <- FALSE
  }
}



#add is_high_blastema column that marks cells with greater than 2% reads == blastema
blastema_cutoff <- 1
rpkm_filtered$is_high_blastema <- NULL
for(i in 1:length(rpkm_filtered$ratio_blastema)){
  if(rpkm_filtered$ratio_blastema[i] > blastema_cutoff) {
    rpkm_filtered$is_high_blastema[i] <- TRUE
  } else {
    rpkm_filtered$is_high_blastema[i] <- FALSE
  }
}

#add info to metadata 
metadata_filtered$is_bastema <- rpkm_filtered$is_blastema
metadata_filtered$is_high_blastema <- rpkm_filtered$is_high_blastema

#save metadata file
write_csv(metadata_filtered, "TCGA_SKCM_metadata.csv")

#remove ratio_blastema and is_blastema from expression matrix to prep for PCA
drops <- c("is_blastema", "ratio_blastema", "is_high_blastema")
rpkm_filtered <- rpkm_filtered[ , !(names(rpkm_filtered) %in% drops)]

#make sample column the rownames of the expression matrix
rpkm_filtered <- column_to_rownames(rpkm_filtered, var = "sample")

#run PCA on expression matrix 
total_pca <- prcomp(rpkm_filtered)

total_pca_scores <- total_pca$x
total_pca_scores <- total_pca_scores %>% 
  # convert to a tibble retaining the sample names as a new column
  as_tibble(rownames = "sample")

total_pca_scores <- merge(total_pca_scores,metadata_filtered, by = "sample" )

total_pca_scores %>% 
  # create the plot
  ggplot(aes(x = PC3, y = PC4)) +
  geom_point(aes(colour = factor(is_high_blastema)))

## calculate MDS (matrix of dissimilarities)
mds <- cmdscale(dist(rpkm_filtered), k=3, eig=TRUE)  
# k = the maximum dimension of the space which the data are to be represented in
# eig = indicates whether eigenvalues should be returned
mds$eig
# transform the Eigen values into percentage
eig_pc <- mds$eig * 100 / sum(mds$eig)
# plot the variance explained by each dimension
barplot(eig_pc,
     las=1,
     xlab="Dimensions", 
     ylab="Proportion of explained variance (%)", y.axis=NULL,
     col="darkgrey")


```
Modeling - linear regression 
```{r}
#create linear regression
lm = lm(ratio_blastema~sample_type, data = rpkm_filtered_blastema_gene_subset_meta)
summary(lm) 

#Residuals:
#    Min      1Q  Median      3Q     Max 
#-0.6551 -0.3529 -0.1705  0.1019 11.2741 
#
#Coefficients:
#                         Estimate Std. Error t value Pr(>|t|)    
#(Intercept)               1.00680    0.03942  25.537   <2e-16 ***
#sample_typePrimary Tumor -0.17418    0.08431  -2.066   0.0394 *  
#---
#Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
#
#Residual standard error: 0.7563 on 469 degrees of freedom
#Multiple R-squared:  0.00902,	Adjusted R-squared:  0.006907 
#F-statistic: 4.269 on 1 and 469 DF,  p-value: 0.03937

#take a look at some model stats 
plot(lm$residuals, pch = 16, col = "red")
plot(cooks.distance(lm), pch = 16, col = "blue")

```

